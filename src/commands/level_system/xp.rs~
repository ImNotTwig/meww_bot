use crate::file_loader::open_level_enabler;
use crate::file_loader::open_server_levels;
use crate::{Context, Error};
use poise::serenity_prelude as sr;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::fs;
use std::io::Write;

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ServerMember {
    pub level: u64,
    pub total_xp: u64,
    pub current_xp: u64,
    pub xp_needed: u64,
    pub can_gain_xp: bool,
}

impl ServerMember {
    pub fn new() -> ServerMember {
        ServerMember {
            level: 0,
            total_xp: 0,
            current_xp: 0,
            xp_needed: 100,
            can_gain_xp: true,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ServerLevels {
    pub members: BTreeMap<String, ServerMember>,
}

#[poise::command(prefix_command, aliases("xp"))]
pub async fn check_xp(
    ctx: Context<'_>,
    #[description = "Which user's xp stats do you want to check. (Leave blank if you want to check yourself.)"]
    mut user: Option<sr::User>,
) -> Result<(), Error> {
    if user == None {
        user = Some(ctx.clone().author().to_owned());
    }

    let user_name = user.clone().unwrap().name.clone();
    let user_id = user.clone().unwrap().id.to_string().to_owned();
    let server_id = ctx.clone().guild_id().unwrap().to_string().to_owned();
    let mut levels = open_server_levels();
    let mut global_levels = levels.get("global").unwrap().clone();

    // checking if the server is in the levels dict
    if !levels.contains_key(&server_id) {
        let new_server = ServerLevels {
            members: BTreeMap::new(),
        };
        levels.insert(server_id.clone(), new_server);

        if !global_levels.clone().members.contains_key(&user_id) {
            global_levels
                .members
                .insert(user_id.clone(), ServerMember::new());
            levels.insert("global".to_string(), global_levels.clone());
        }

        let buf = Vec::new();
        let formatter = serde_json::ser::PrettyFormatter::with_indent(b"    ");
        let mut ser = serde_json::Serializer::with_formatter(buf, formatter);
        levels.serialize(&mut ser).unwrap();

        let mut level_file = fs::File::create("./src/commands/level_system/levels.json").unwrap();
        write!(
            level_file,
            "{}",
            String::from_utf8(ser.into_inner()).unwrap()
        )
        .unwrap();
        levels = open_server_levels();
    }
    // checking if the member is in the server dict
    if !levels
        .get(&server_id)
        .unwrap()
        .members
        .contains_key(&user_id)
    {
        let mut server_members = levels.get(&server_id).unwrap().members.clone();
        server_members.insert(user_id.clone(), ServerMember::new());
        let mut server_levels = levels.get(&server_id).unwrap().clone();
        server_levels.members = server_members;

        levels.insert(server_id.clone(), server_levels);

        if !global_levels.clone().members.contains_key(&user_id) {
            global_levels
                .members
                .insert(user_id.clone(), ServerMember::new());
            levels.insert("global".to_string(), global_levels.clone());
        }

        let buf = Vec::new();
        let formatter = serde_json::ser::PrettyFormatter::with_indent(b"    ");
        let mut ser = serde_json::Serializer::with_formatter(buf, formatter);
        levels.serialize(&mut ser).unwrap();

        let mut level_file = fs::File::create("./src/commands/level_system/levels.json").unwrap();
        write!(
            level_file,
            "{}",
            String::from_utf8(ser.into_inner()).unwrap()
        )
        .unwrap();
        levels = open_server_levels();
    }

    let user_pfp = user.unwrap().avatar_url().unwrap();

    let global_xp = levels
        .get("global")
        .unwrap()
        .members
        .get(&user_id)
        .unwrap()
        .total_xp;

    let global_level = levels
        .get("global")
        .unwrap()
        .members
        .get(&user_id)
        .unwrap()
        .level;

    let xp = levels
        .get(&server_id)
        .unwrap()
        .members
        .get(&user_id)
        .unwrap()
        .current_xp;

    let level = levels
        .get(&server_id)
        .unwrap()
        .members
        .get(&user_id)
        .unwrap()
        .level;

    let xp_needed = levels
        .get(&server_id)
        .unwrap()
        .members
        .get(&user_id)
        .unwrap()
        .xp_needed;

    let xp_needed_to_level_up = xp_needed - xp;
    let amount_per_box = xp_needed / 20;
    let current_boxes = xp / amount_per_box;
    let boxes_left = xp_needed_to_level_up / amount_per_box;

    let blue_squares = ":blue_square:"
        .to_string()
        .repeat(usize::try_from(current_boxes).unwrap());
    let white_squares = ":white_large_square:"
        .to_string()
        .repeat(usize::try_from(boxes_left).unwrap());

    ctx.channel_id()
        .send_message(&ctx.discord().http, |m| {
            m.embed(|e| {
                e.thumbnail(user_pfp)
                    .title(format!("{}'s Level Stats", user_name))
                    .field("Global Xp", global_xp, true)
                    .field("Global Level", global_level, true)
                    .field(format!("{}'s Xp", user_name), xp, true)
                    .field(format!("{}'s Level", user_name), level, true)
                    .field(
                        format!("Progress to leveling up in {}", ctx.guild().unwrap().name),
                        format!("{}{}", blue_squares, white_squares),
                        false,
                    )
            })
        })
        .await?;

    Ok(())
}

#[poise::command(prefix_command, aliases("levelswitch"))]
pub async fn levels(
    ctx: Context<'_>,
    #[description = "Do you want to turn the level system on or off?"] mut on_or_off: String,
) -> Result<(), Error> {
    let mut server_enabler = open_level_enabler();
    let server_id = ctx.clone().guild_id().unwrap().to_string();

    if &on_or_off.to_lowercase() == "on" || &on_or_off.to_lowercase() == "true" {
        server_enabler.insert(server_id, true);
        on_or_off = "on".to_string();
    } else if &on_or_off.to_lowercase() == "off" || &on_or_off == "false" {
        server_enabler.insert(server_id, false);
        on_or_off = "off".to_string();
    }

    println!("{:?}", &on_or_off);

    let buf = Vec::new();
    let formatter = serde_json::ser::PrettyFormatter::with_indent(b"    ");
    let mut ser = serde_json::Serializer::with_formatter(buf, formatter);
    server_enabler.serialize(&mut ser).unwrap();

    let mut server_enabler_file =
        fs::File::create("./src/commands/level_system/server_enabler.json").unwrap();

    write!(
        server_enabler_file,
        "{}",
        String::from_utf8(ser.into_inner()).unwrap()
    )
    .unwrap();

    ctx.say(format!(
        "The level system for {} has been turned {}",
        ctx.guild().unwrap().name,
        on_or_off
    ))
    .await?;

    Ok(())
}
